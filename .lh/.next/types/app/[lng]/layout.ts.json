{
    "sourceFile": ".next/types/app/[lng]/layout.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1699189120183,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1699189120183,
            "name": "Commit-0",
            "content": "// File: /Users/kon/Projects/school/my-edu-front/app/[lng]/layout.tsx\nimport * as entry from \"../../../../app/[locale]/layout.jsx\";\nimport type {\n  ResolvingMetadata,\n  ResolvingViewport,\n} from \"next/dist/lib/metadata/types/metadata-interface.js\";\n\ntype TEntry = typeof import(\"../../../../app/[locale]/layout.jsx\");\n\n// Check that the entry is a valid entry\ncheckFields<\n  Diff<\n    {\n      default: Function;\n      config?: {};\n      generateStaticParams?: Function;\n      revalidate?: RevalidateRange<TEntry> | false;\n      dynamic?: \"auto\" | \"force-dynamic\" | \"error\" | \"force-static\";\n      dynamicParams?: boolean;\n      fetchCache?:\n        | \"auto\"\n        | \"force-no-store\"\n        | \"only-no-store\"\n        | \"default-no-store\"\n        | \"default-cache\"\n        | \"only-cache\"\n        | \"force-cache\";\n      preferredRegion?: \"auto\" | \"global\" | \"home\" | string | string[];\n      runtime?: \"nodejs\" | \"experimental-edge\" | \"edge\";\n      maxDuration?: number;\n\n      metadata?: any;\n      generateMetadata?: Function;\n      viewport?: any;\n      generateViewport?: Function;\n    },\n    TEntry,\n    \"\"\n  >\n>();\n\n// Check the prop type of the entry function\ncheckFields<Diff<LayoutProps, FirstArg<TEntry[\"default\"]>, \"default\">>();\n\n// Check the arguments and return type of the generateMetadata function\nif (\"generateMetadata\" in entry) {\n  checkFields<\n    Diff<\n      LayoutProps,\n      FirstArg<MaybeField<TEntry, \"generateMetadata\">>,\n      \"generateMetadata\"\n    >\n  >();\n  checkFields<\n    Diff<\n      ResolvingMetadata,\n      SecondArg<MaybeField<TEntry, \"generateMetadata\">>,\n      \"generateMetadata\"\n    >\n  >();\n}\n\n// Check the arguments and return type of the generateViewport function\nif (\"generateViewport\" in entry) {\n  checkFields<\n    Diff<\n      LayoutProps,\n      FirstArg<MaybeField<TEntry, \"generateViewport\">>,\n      \"generateViewport\"\n    >\n  >();\n  checkFields<\n    Diff<\n      ResolvingViewport,\n      SecondArg<MaybeField<TEntry, \"generateViewport\">>,\n      \"generateViewport\"\n    >\n  >();\n}\n\n// Check the arguments and return type of the generateStaticParams function\nif (\"generateStaticParams\" in entry) {\n  checkFields<\n    Diff<\n      { params: PageParams },\n      FirstArg<MaybeField<TEntry, \"generateStaticParams\">>,\n      \"generateStaticParams\"\n    >\n  >();\n  checkFields<\n    Diff<\n      {\n        __tag__: \"generateStaticParams\";\n        __return_type__: any[] | Promise<any[]>;\n      },\n      {\n        __tag__: \"generateStaticParams\";\n        __return_type__: ReturnType<MaybeField<TEntry, \"generateStaticParams\">>;\n      }\n    >\n  >();\n}\n\ntype PageParams = any;\nexport interface PageProps {\n  params?: any;\n  searchParams?: any;\n}\nexport interface LayoutProps {\n  children?: React.ReactNode;\n\n  params?: any;\n}\n\n// =============\n// Utility types\ntype RevalidateRange<T> = T extends { revalidate: any }\n  ? NonNegative<T[\"revalidate\"]>\n  : never;\n\n// If T is unknown or any, it will be an empty {} type. Otherwise, it will be the same as Omit<T, keyof Base>.\ntype OmitWithTag<T, K extends keyof any, _M> = Omit<T, K>;\ntype Diff<Base, T extends Base, Message extends string = \"\"> = 0 extends 1 & T\n  ? {}\n  : OmitWithTag<T, keyof Base, Message>;\n\ntype FirstArg<T extends Function> = T extends (...args: [infer T, any]) => any\n  ? unknown extends T\n    ? any\n    : T\n  : never;\ntype SecondArg<T extends Function> = T extends (...args: [any, infer T]) => any\n  ? unknown extends T\n    ? any\n    : T\n  : never;\ntype MaybeField<T, K extends string> = T extends { [k in K]: infer G }\n  ? G extends Function\n    ? G\n    : never\n  : never;\n\nfunction checkFields<_ extends { [k in keyof any]: never }>() {}\n\n// https://github.com/sindresorhus/type-fest\ntype Numeric = number | bigint;\ntype Zero = 0 | 0n;\ntype Negative<T extends Numeric> = T extends Zero\n  ? never\n  : `${T}` extends `-${string}`\n  ? T\n  : never;\ntype NonNegative<T extends Numeric> = T extends Zero\n  ? T\n  : Negative<T> extends never\n  ? T\n  : \"__invalid_negative_number__\";\n"
        }
    ]
}